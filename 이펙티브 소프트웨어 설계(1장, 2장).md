# 이펙티브 소프트웨어 설계(1장, 2장)


# 1장 – 설계에서의 현실적인 판단과 구조적 선택

## 트레이드오프(trade-off)의 뜻 상충관계. 즉, 하나를 얻으면 다른 하나를 잃을 수 있는 관계를 말한다.

## 소프트웨어 설계는 트레이드오프의 연속이다
소프트웨어 설계는 다양한 품질 속성 사이에서 균형을 맞추는 과정이다.  
성능을 극대화하려 하면 구조가 복잡해지고, 유지보수를 고려하면 실행 효율이 떨어질 수 있다.  
예를 들어, 캐시를 도입하면 처리 속도는 빨라지지만 메모리 사용량이 증가하고 동기화 이슈가 발생할 수 있다.  
이처럼 설계는 언제나 장점과 단점이 공존하는 선택의 연속이며, 이를 트레이드오프라 한다.

## 테스트는 품질 확보의 전략이다
테스트는 단순한 오류 검출 수단을 넘어, 시스템의 안정성과 변화 대응력을 보장하기 위한 핵심 전략이다.  
단위 테스트는 작성이 쉽고 실행이 빠르지만, 실제 운영 시나리오를 포괄하지 못하는 경우가 많다.  
반면 통합 테스트는 사용자 관점에서 시스템 흐름을 확인할 수 있지만, 유지보수가 어렵고 실행 속도도 느리다.  
따라서 테스트 전략은 시스템 리스크에 따라 적절한 테스트를 조합해 구성해야 한다.

## 디자인 패턴의 실용적 접근
디자인 패턴은 반복적으로 나타나는 문제에 대한 검증된 해법이다.  
하지만 상황에 따라 그 유용성이 달라지며, 무조건 사용하는 것은 오히려 해가 될 수 있다.  
예를 들어, 싱글턴 패턴은 전역 상태를 하나의 인스턴스로 제한하는 방식이지만, 구현 방식에 따라 성능이나 안정성에 큰 차이를 보인다.

### Synchronized 방식
```java
public class Singleton {
    private static Singleton instance;
    public static synchronized Singleton getInstance() {
        if (instance == null) instance = new Singleton();
        return instance;
    }
}
```
간단하지만 호출마다 동기화가 발생해 성능이 떨어질 수 있다.

### Double Checked Locking 방식
```java
public class DCLSingleton {
    private static volatile DCLSingleton instance;
    public static DCLSingleton getInstance() {
        if (instance == null) {
            synchronized(DCLSingleton.class) {
                if (instance == null) instance = new DCLSingleton();
            }
        }
        return instance;
    }
}
```
동기화 구간을 최소화해 성능을 개선했지만 구현이 복잡하다.

### ThreadLocal 방식
```java
public class ThreadLocalSingleton {
    private static final ThreadLocal<ThreadLocalSingleton> instance =
        ThreadLocal.withInitial(ThreadLocalSingleton::new);
    public static ThreadLocalSingleton getInstance() {
        return instance.get();
    }
}
```
스레드별 인스턴스를 가지므로 동시성 문제를 피할 수 있지만, 메모리 누수 위험이 존재한다.

## 실제 벤치마크 결과의 의미
동일한 기능도 구현 방식에 따라 성능 차이가 크게 발생한다.  
벤치마크 결과, synchronized 방식은 느리고, double-checked locking이나 ThreadLocal 방식은 더 나은 성능을 보였다.  
이처럼 설계의 세부 구현이 시스템 전체 성능에 직접적인 영향을 줄 수 있다.

## 아키텍처는 상황에 맞는 구조를 선택하는 일이다
모놀리식 아키텍처는 단일 배포와 빠른 개발이 가능하지만, 시스템이 커질수록 유지보수가 어려워지고 확장성이 떨어진다.  
반면 마이크로서비스 아키텍처는 서비스 단위를 분리해 유연한 확장이 가능하지만, 네트워크 지연, 장애 전파, 운영 복잡도 등의 문제를 수반한다.  
설계자는 프로젝트의 규모, 팀 구성, 인프라 수준 등을 고려하여 가장 적절한 구조를 선택해야 한다.

## 결론
설계는 문제 해결의 예술이다.  
단순히 기술을 적용하는 것이 아니라, 현재 상황에 가장 적합한 해결책을 균형 있게 선택하는 판단의 연속이다.  
도구와 패턴은 수단일 뿐이며, 설계의 핵심은 '왜 그렇게 했는가'를 설명할 수 있는 선택에 있다.



# 2장 – 코드 중복, 공통화, 그리고 적절한 분리 전략

## 코드 중복의 현실
코드 중복은 대부분의 개발자에게 부정적인 요소로 여겨지지만, 모든 중복이 나쁜 것은 아니다.  
초기 개발 속도를 높이거나 팀 간 의사소통 비용을 줄이는 등, 상황에 따라 중복이 더 효율적인 경우도 존재한다.  
따라서 중복을 제거할지 유지할지는 무조건적인 기준이 아닌, 맥락에 따라 전략적으로 판단해야 한다.

## 공통 코드의 모듈화
공통 기능은 하나의 모듈로 분리하여 여러 프로젝트에서 사용할 수 있도록 구성하는 것이 일반적인 접근 방식이다.  
이렇게 하면 코드의 일관성을 유지할 수 있고, 유지보수 효율도 높아진다.  
그러나 공통 모듈은 배포 및 의존성 관리가 필요하며, 모든 프로젝트에 적절하게 맞춰야 하기 때문에 범용성과 안정성이 요구된다.

## 공통 기능의 외부 서비스화
공통 로직이 더 이상 단순한 코드 재사용의 차원이 아니라면, 별도의 서비스로 분리할 수도 있다.  
예를 들어 인증, 결제, 로그 수집 등의 기능은 다른 시스템에서도 필요할 수 있으므로, 독립적인 마이크로서비스로 제공하면 효과적이다.  
이 방식은 유연성과 독립성이 크지만, 네트워크 통신 비용과 장애 전파 문제, SLA 관리 등 운영적 복잡성이 수반된다.  
따라서 기술적인 준비와 조직적인 합의가 병행되어야 성공적으로 도입할 수 있다.

## 상속 기반 공통 구조 설계

### 추상 클래스 정의
```java
public abstract class TraceRequest {
    private final String userId;
    public TraceRequest(String userId) {
        this.userId = userId;
    }
    public abstract boolean isTraceEnabled();
}
```

### 하위 클래스 구현
```java
public class GraphTraceRequest extends TraceRequest {
    public GraphTraceRequest(String userId) {
        super(userId);
    }
    @Override
    public boolean isTraceEnabled() {
        return true;
    }
}
```

상속은 공통 로직을 상위 클래스에 정의하고, 하위 클래스는 필요한 부분만 오버라이드하여 사용하는 구조로, 일관된 사용 패턴을 유지할 수 있다.  
하지만 클래스 간 결합도가 높아지고 유연성이 떨어질 수 있어, 과도한 상속은 지양해야 한다.

## 합성을 통한 유연한 구성
합성은 객체를 내부에 포함시키는 방식으로 기능을 구성하며, 필요한 기능만 선택적으로 조합할 수 있다.  
이는 상속보다 유연성이 뛰어나고 테스트도 용이하다는 장점이 있다.  
다만 컴포넌트 간 명확한 역할 분리가 필요하고, 설계 복잡도가 증가할 수 있다.

## 중복의 본질과 판단 기준
두 코드가 유사해 보여도, 그 목적이나 컨텍스트가 다르면 공통화해서는 안 된다.  
예를 들어, 입력 유효성 검사를 담당하는 두 클래스가 유사한 로직을 갖고 있어도, 하나는 API 요청 검증, 다른 하나는 사용자 입력 처리용이라면 그 목적이 다르다.  
이런 경우 공통화하면 오히려 의미를 흐리고 유지보수를 어렵게 만들 수 있다.  
우연한 중복과 본질적인 중복을 구분하는 것이 중요하다.

## 결론
코드 중복은 제거 그 자체가 목표가 아니라, 유지보수성과 시스템 복잡도를 고려한 전략적 판단의 대상이다.  
모듈화, 상속, 합성, 서비스화 등 다양한 방식은 각각 장단점이 있으며, 상황에 따라 유연하게 선택해야 한다.  
설계자는 팀의 조직 구조, 기술 성숙도, 시스템 아키텍처 등을 종합적으로 고려해 중복에 접근해야 한다.

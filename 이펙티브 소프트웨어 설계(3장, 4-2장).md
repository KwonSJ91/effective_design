# Java 예외 처리 패턴 요약본

## 03. 코드에서 신경 써야 할 예외와 오류 처리 패턴

### 3.1 예외의 계층 구조

**Java 예외 시스템의 핵심 구조**

Java에서 모든 예외는 `Throwable`을 상속받는 객체로, 크게 두 가지로 분류됩니다:

```
Object
   ↓
Throwable
   ↓
Exceptions ←——————————————————→ Error
   ↓                              ↓
확인된(Checked)               VirtualMachineError
- IOException                     ↓
- InterruptedException      AssertionError 등
   ↓
확인되지 않은(Unchecked)
- IllegalArgumentException
- NullPointerException
```

**확인된 예외(Checked Exception)**
- 컴파일 타임에 처리를 강제하는 예외
- 메서드 시그니처에 `throws` 선언 필요
- 복구 가능한 예외 상황에 주로 사용
- 예: `IOException`, `InterruptedException`

**확인되지 않은 예외(Unchecked Exception)**
- 컴파일러가 처리를 강제하지 않는 예외
- `RuntimeException`을 상속받음
- 프로그래밍 오류나 논리적 오류에 주로 사용
- 예: `IllegalArgumentException`, `NullPointerException`

**예외 처리 세분화 전략**

세분화된 예외 처리는 각각의 예외 상황에 맞는 적절한 대응을 가능하게 합니다:

```java
// 구체적 예외별 처리 - 권장 방식
public void shouldCatchAtNormalGranularity() {
    try {
        methodThatThrowsCheckedException();
    } catch (FileAlreadyExistsException e) {
        logger.error("File already exists: ", e);
        // 파일이 이미 존재하는 경우의 구체적 처리
    } catch (InterruptedException e) {
        logger.error("Interrupted", e);
        Thread.currentThread().interrupt(); // 인터럽트 상태 복원
    }
}

// 상위 타입으로 포괄적 처리
public void shouldCatchAtHigherGranularity() {
    try {
        methodThatThrowsCheckedException();
    } catch (IOException e) {
        // FileAlreadyExistsException도 IOException을 상속받으므로 여기서 처리
        logger.error("IO problem occurred: ", e);
    } catch (InterruptedException e) {
        logger.error("Interrupted", e);
    }
}

// 모든 예외를 한 번에 처리 - 주의해서 사용
public void shouldCatchAtCatchAll() {
    try {
        methodThatThrowsCheckedException();
    } catch (Exception e) {
        logger.error("Unexpected problem occurred: ", e);
        // 모든 예외를 동일하게 처리하므로 구체적 대응 불가
    }
}
```

### 3.2 API에서의 예외 처리 모범 사례

공개 API를 설계할 때는 호출자가 예상할 수 있고 적절히 대응할 수 있는 예외 전략이 중요합니다.

#### 3.2.1 공개 API에서 Checked Exception 처리

**명시적 예외 선언**
```java
// API 메서드에서 발생할 수 있는 예외를 명시적으로 선언
void check() throws IOException, InterruptedException;
```

**Checked Exception을 Unchecked로 감싸기**
```java
public void wrapIntoUnchecked() {
    try {
        check();
    } catch (RuntimeException e) {
        throw e; // RuntimeException은 그대로 전파
    } catch (Exception e) {
        // Checked Exception을 RuntimeException으로 감싸서 전파
        throw new RuntimeException(e);
    }
}
```

이 패턴은 다음과 같은 장점이 있습니다:
- 호출자가 예외 처리를 강제받지 않음
- 원본 예외 정보는 cause로 보존
- API 사용성 향상

#### 3.2.2 공개 API에서 Unchecked Exception 처리

**입력 검증과 상태 검증**
```java
public void setupService(int numberOfThreads)
    throws IllegalStateException, IllegalArgumentException {
    
    // 입력값 검증
    if (numberOfThreads < 0) {
        throw new IllegalArgumentException(
            "Number of threads cannot be lower than 0.");
    }
    
    // 객체 상태 검증
    if (running) {
        throw new IllegalStateException(
            "The service is already running.");
    }
    
    // 정상 로직 수행
    this.numberOfThreads = numberOfThreads;
    this.running = true;
}
```

Unchecked Exception 사용 시 고려사항:
- **IllegalArgumentException**: 잘못된 매개변수 전달 시
- **IllegalStateException**: 객체가 부적절한 상태일 때
- **NullPointerException**: null 값이 허용되지 않을 때

### 3.3 예외 처리 안티 패턴과 올바른 자원 관리

#### 3.3.1 자원 해제 패턴

**잘못된 자원 관리**
```java
CloseableHttpClient client = HttpClients.createDefault();
try {
    processRequests(client);
    client.close(); // 예외 발생 시 실행되지 않음
} catch (IOException e) {
    logger.error("Problem", e);
}
```

**try-with-resources 사용 (권장)**
```java
try (CloseableHttpClient client = HttpClients.createDefault()) {
    processRequests(client);
} catch (IOException e) {
    logger.error("Problem when processing requests", e);
}
// client.close()가 자동으로 호출됨
```

**finally 블록 사용 (필요시)**
```java
CloseableHttpClient client = HttpClients.createDefault();
try {
    processRequests(client);
} finally {
    if (client != null) {
        try {
            client.close();
        } catch (IOException e) {
            logger.warn("Failed to close client", e);
        }
    }
}
```

#### try-with-resources의 장점
- 자동 자원 해제로 메모리 누수 방지
- 예외 발생 시에도 안전한 자원 정리
- 코드 간소화 및 가독성 향상
- suppressed exception 처리

### 3.4 타사 라이브러리 예외 처리

외부 라이브러리의 예외를 그대로 노출하면 강한 결합이 발생합니다. 도메인별 예외를 만들어 결합도를 낮춰야 합니다.

**도메인 전용 예외 클래스 설계**
```java
public class PersonCatalogException extends Exception {
    // private 생성자로 직접 생성 방지
    private PersonCatalogException(String message, Throwable cause) {
        super(message, cause);
    }
    
    // 정적 팩토리 메서드로 의미있는 예외 생성
    public static PersonCatalogException getPersonException(String personName, Throwable t) {
        return new PersonCatalogException(
            "Problem when getting person file for: " + personName, t);
    }
    
    public static PersonCatalogException createPersonException(String personName, Throwable t) {
        return new PersonCatalogException(
            "Problem when creating person file for: " + personName, t);
    }
}
```

**API 인터페이스에서 도메인 예외 사용**
```java
public interface PersonCatalog {
    // 타사 라이브러리 예외(FileExistsException) 대신 도메인 예외 사용
    PersonInfo getPersonInfo(String personName) throws PersonCatalogException;
    boolean createPersonInfo(String personName, int amount) throws PersonCatalogException;
}
```

**구현체에서 예외 변환**
```java
public class PersonCatalogImpl implements PersonCatalog {
    @Override
    public PersonInfo getPersonInfo(String personName) throws PersonCatalogException {
        try {
            // 타사 라이브러리 API 호출
            return externalLibrary.readPersonFile(personName);
        } catch (FileNotFoundException e) {
            throw PersonCatalogException.getPersonException(personName, e);
        } catch (IOException e) {
            throw PersonCatalogException.getPersonException(personName, e);
        }
    }
}
```

### 3.5 멀티스레드 환경에서의 예외 처리

비동기 프로그래밍에서는 예외가 다른 스레드에서 발생하므로 특별한 처리가 필요합니다.

#### 3.5.1 CompletableFuture를 이용한 예외 처리

**기본적인 비동기 예외 처리**
```java
public CompletableFuture<Integer> asyncExternalCall() {
    return CompletableFuture.supplyAsync(() -> {
        try {
            return externalCall(); // IOException을 던질 수 있는 메서드
        } catch (IOException e) {
            // Checked Exception을 Unchecked로 변환
            throw new RuntimeException(e);
        }
    });
}
```

**명시적 완성 처리**
```java
public CompletableFuture<Integer> betterAsyncCall() {
    CompletableFuture<Integer> future = new CompletableFuture<>();
    CompletableFuture.runAsync(() -> {
        try {
            Integer result = externalCall();
            future.complete(result); // 성공 시 결과 설정
        } catch (IOException e) {
            future.completeExceptionally(e); // 실패 시 예외 설정
        }
    });
    return future;
}
```

**예외 체인 처리**
```java
CompletableFuture<String> result = asyncExternalCall()
    .thenApply(value -> value.toString())
    .exceptionally(throwable -> {
        logger.error("Async operation failed", throwable);
        return "DEFAULT_VALUE";
    });
```

### 3.6 Try 모나드를 통한 함수형 오류 처리

함수형 프로그래밍에서는 예외 대신 `Try` 모나드를 사용하여 오류를 값으로 다룹니다.

**Try 모나드의 기본 사용법**
```java
// 성공하는 경우
String defaultResult = "default";
Supplier<Integer> clientAction = () -> 100;

Try<Integer> response = Try.ofSupplier(clientAction);
String result = response.map(Object::toString).getOrElse(defaultResult);
// 결과: "100"

// 실패하는 경우
Supplier<Integer> failingAction = () -> {
    throw new RuntimeException("problem");
};

Try<Integer> failedResponse = Try.ofSupplier(failingAction);
String failedResult = failedResponse.map(Object::toString).getOrElse(defaultResult);
// 결과: "default"
```

**실제 HTTP 서비스 호출 예제**
```java
public String getId() {
    CloseableHttpClient client = HttpClients.createDefault();
    HttpGet httpGet = new HttpGet("http://external-service/resource");
    
    Try<HttpResponse> response = Try.of(() -> client.execute(httpGet));
    return response
        .mapTry(this::extractStringBody)    // IOException을 던질 수 있는 메서드
        .mapTry(this::toEntity)             // JsonProcessingException 가능
        .map(this::extractUserId)           // 안전한 변환
        .onFailure(ex -> logger.error("The getId() failed.", ex))
        .getOrElse("DEFAULT_ID");
}

private String extractStringBody(HttpResponse response) throws IOException {
    return new BufferedReader(
        new InputStreamReader(response.getEntity().getContent(),
            StandardCharsets.UTF_8))
        .lines()
        .collect(Collectors.joining("\n"));
}
```

**Try vs 전통적 예외 처리 비교**
```java
// Try 모나드 방식 - 함수형
public String getIdWithTry() {
    return Try.of(() -> externalService.call())
        .mapTry(this::processResponse)
        .map(this::extractId)
        .recover(throwable -> "DEFAULT_ID")
        .get();
}

// 전통적 예외 처리 방식
public String getIdWithExceptions() {
    try {
        String response = externalService.call();
        ProcessedData data = processResponse(response);
        return extractId(data);
    } catch (Exception e) {
        logger.error("Failed to get ID", e);
        return "DEFAULT_ID";
    }
}
```

### 3.7 성능 비교 및 고려사항

JMH(Java Microbenchmark Harness)를 이용한 성능 측정 결과:

**벤치마크 결과 분석**
- **baseline** (일반 객체 생성): ~1ms
- **throwCatch** (예외 생성/처리): ~100ms
- **getStackTrace** (스택 추적 포함): ~2500ms
- **Try 모나드**: ~100ms (throwCatch와 유사)

**성능 최적화 지침**
1. **스택 추적이 성능에 가장 큰 영향**: 필요하지 않다면 스택 추적 사용 최소화
2. **Try 모나드 vs 예외 처리**: 성능 차이는 미미하므로 코드 스타일과 팀 선호도에 따라 선택
3. **예외는 예외적 상황에만**: 정상적인 제어 흐름에는 사용하지 말 것

## 04. 유연성과 복잡성 사이의 균형

### 4.1 견고하지만 확장성이 떨어지는 API

실제 프로덕션 환경에서 사용할 수 있는 HTTP 클라이언트 예제를 통해 API 설계의 진화를 살펴봅시다.

#### 재시도 로직을 가진 HTTP 클라이언트 설계

**초기 구현 - 단순하지만 유연성 부족**
```java
public class HttpClientExecution {
    private final int maxNumberOfRetries;
    private final CloseableHttpClient client;
    private final Meter successMeter;
    private final Meter failureMeter;
    private final Meter retryCounter;

    public HttpClientExecution(
        MetricRegistry metricRegistry, 
        int maxNumberOfRetries,
        CloseableHttpClient client) {
        
        this.successMeter = metricRegistry.meter("requests.success");
        this.failureMeter = metricRegistry.meter("requests.failure");
        this.retryCounter = metricRegistry.meter("requests.retry");
        this.maxNumberOfRetries = maxNumberOfRetries;
        this.client = client;
    }

    public void executeWithRetry(String path) {
        for (int i = 0; i <= maxNumberOfRetries; i++) {
            try {
                execute(path);
                return; // 성공 시 즉시 반환
            } catch (IOException e) {
                logger.error("Request failed, retry: " + i, e);
                failureMeter.mark();
                
                if (maxNumberOfRetries == i) {
                    logger.error("Max retries reached, failing.");
                    throw new RuntimeException(e);
                } else {
                    logger.info("Retrying request...");
                    retryCounter.mark();
                }
            }
        }
    }

    private void execute(String path) throws IOException {
        CloseableHttpResponse response = client.execute(new HttpPost(path));
        if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {
            successMeter.mark();
        } else {
            failureMeter.mark();
        }
    }
}
```

**이 구현의 한계점**
- 특정 메트릭 라이브러리(Codahale Metrics)에 강하게 결합
- 다른 메트릭 시스템 사용 시 코드 수정 필요
- 확장성과 유연성 부족

### 4.2 클라이언트 맞춤형 메트릭 프레임워크 지원

타사 라이브러리 의존성을 줄이고 유연성을 높이기 위한 추상화 도입:

#### 메트릭 추상화 레이어 설계

**메트릭 인터페이스 정의**
```java
public interface MetricsProvider {
    void incrementSuccess();
    void incrementFailure();
    void incrementRetry();
}
```

**구체적 구현체 - Codahale Metrics**
```java
public class DefaultMetricsProvider implements MetricsProvider {
    private final Meter successMeter;
    private final Meter failureMeter;
    private final Meter retryCounter;
    
    public DefaultMetricsProvider(MetricRegistry metricRegistry) {
        this.successMeter = metricRegistry.meter("requests.success");
        this.failureMeter = metricRegistry.meter("requests.failure");
        this.retryCounter = metricRegistry.meter("requests.retry");
    }
    
    @Override
    public void incrementSuccess() {
        successMeter.mark();
    }
    
    @Override
    public void incrementFailure() {
        failureMeter.mark();
    }
    
    @Override
    public void incrementRetry() {
        retryCounter.mark();
    }
}
```

**개선된 HttpClientExecution**
```java
public class HttpClientExecution {
    private final int maxNumberOfRetries;
    private final CloseableHttpClient client;
    private final MetricsProvider metricsProvider; // 추상화된 인터페이스 사용

    public HttpClientExecution(
        MetricsProvider metricsProvider,
        int maxNumberOfRetries,
        CloseableHttpClient client) {
        
        this.metricsProvider = metricsProvider;
        this.maxNumberOfRetries = maxNumberOfRetries;
        this.client = client;
    }

    public void executeWithRetry(String path) {
        for (int i = 0; i <= maxNumberOfRetries; i++) {
            try {
                execute(path);
                return;
            } catch (IOException e) {
                logger.error("Request failed, retry: " + i, e);
                metricsProvider.incrementFailure(); // 추상화된 메서드 호출
                
                if (maxNumberOfRetries == i) {
                    throw new RuntimeException(e);
                } else {
                    metricsProvider.incrementRetry();
                }
            }
        }
    }

    private void execute(String path) throws IOException {
        CloseableHttpResponse response = client.execute(new HttpPost(path));
        if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {
            metricsProvider.incrementSuccess();
        } else {
            metricsProvider.incrementFailure();
        }
    }
}
```

**다른 메트릭 시스템을 위한 구현체 예제**
```java
// Micrometer를 사용하는 구현체
public class MicrometerMetricsProvider implements MetricsProvider {
    private final Counter successCounter;
    private final Counter failureCounter;
    private final Counter retryCounter;
    
    public MicrometerMetricsProvider(MeterRegistry meterRegistry) {
        this.successCounter = Counter.builder("requests.success")
            .register(meterRegistry);
        this.failureCounter = Counter.builder("requests.failure")
            .register(meterRegistry);
        this.retryCounter = Counter.builder("requests.retry")
            .register(meterRegistry);
    }
    
    @Override
    public void incrementSuccess() {
        successCounter.increment();
    }
    
    @Override
    public void incrementFailure() {
        failureCounter.increment();
    }
    
    @Override
    public void incrementRetry() {
        retryCounter.increment();
    }
}
```

**사용 예제**
```java
// Codahale Metrics 사용
MetricRegistry codahaleRegistry = new MetricRegistry();
MetricsProvider codahaleProvider = new DefaultMetricsProvider(codahaleRegistry);
HttpClientExecution client1 = new HttpClientExecution(codahaleProvider, 3, httpClient);

// Micrometer 사용
MeterRegistry micrometerRegistry = new SimpleMeterRegistry();
MetricsProvider micrometerProvider = new MicrometerMetricsProvider(micrometerRegistry);
HttpClientExecution client2 = new HttpClientExecution(micrometerProvider, 3, httpClient);
```

**이 설계의 장점**
- **낮은 결합도**: 특정 메트릭 라이브러리에 의존하지 않음
- **높은 확장성**: 새로운 메트릭 시스템 쉽게 추가 가능
- **테스트 용이성**: Mock 객체로 쉽게 테스트 가능
- **재사용성**: 다양한 환경에서 동일한 코드 재사용

## 핵심 원칙 및 베스트 프랙티스

### 반드시 해야 할 것

**1. 구체적이고 의미있는 예외 사용**
```java
// 잘못된 예
throw new Exception("Something went wrong");

// 올바른 예
throw new IllegalArgumentException("Age cannot be negative: " + age);
```

**2. 자원 자동 관리**
```java
// try-with-resources 사용
try (FileInputStream fis = new FileInputStream(file);
     BufferedReader reader = new BufferedReader(new InputStreamReader(fis))) {
    return reader.lines().collect(Collectors.toList());
}
```

**3. 도메인 예외로 타사 라이브러리 격리**
```java
// 도메인 예외로 감싸기
public void saveUser(User user) throws UserServiceException {
    try {
        database.save(user);
    } catch (SQLException e) {
        throw new UserServiceException("Failed to save user: " + user.getId(), e);
    }
}
```

**4. 적절한 로깅과 메트릭**
```java
try {
    processRequest(request);
    metricsProvider.incrementSuccess();
} catch (Exception e) {
    logger.error("Failed to process request: {}", request.getId(), e);
    metricsProvider.incrementFailure();
    throw new ProcessingException("Request processing failed", e);
}
```

### 절대 하지 말아야 할 것

**1. 예외 무시**
```java
// 절대 금지
try {
    riskyOperation();
} catch (Exception e) {
    // 무시하지 말 것!
}

// 최소한 로깅
try {
    riskyOperation();
} catch (Exception e) {
    logger.warn("Operation failed, continuing with default behavior", e);
    useDefaultBehavior();
}
```

**2. 과도한 일반화**
```java
// 모든 예외를 동일하게 처리
try {
    complexOperation();
} catch (Exception e) {
    return "error";
}

// 예외별 적절한 처리
try {
    complexOperation();
} catch (ValidationException e) {
    return handleValidationError(e);
} catch (NetworkException e) {
    return handleNetworkError(e);
} catch (Exception e) {
    logger.error("Unexpected error", e);
    return handleUnexpectedError(e);
}
```

**3. 제어 흐름 목적으로 예외 사용**
```java
// 제어 흐름에 예외 사용 금지
try {
    return users.get(index);
} catch (IndexOutOfBoundsException e) {
    return null;
}

// 적절한 조건 검사
if (index >= 0 && index < users.size()) {
    return users.get(index);
}
return null;
```

### 성능 최적화 가이드

**1. 스택 추적 비용 인식**
```java
// 성능이 중요한 경우 스택 추적 없는 예외 사용 고려
public class NoStackTraceException extends RuntimeException {
    @Override
    public synchronized Throwable fillInStackTrace() {
        return this; // 스택 추적 생성하지 않음
    }
}
```

**2. 예외 객체 재사용 (매우 특수한 경우)**
```java
// 매우 빈번한 예외의 경우에만 고려
private static final IllegalStateException INVALID_STATE = 
    new IllegalStateException("Invalid state");

// 사용 시
if (state != VALID) {
    throw INVALID_STATE;
}
```

**3. 조건 검사 우선**
```java
// 예외보다는 조건 검사가 성능상 유리
public String getProperty(String key) {
    if (key == null || properties == null) {
        return null;
    }
    return properties.get(key);
}
```

이러한 원칙들을 따르면 견고하고 유지보수하기 쉬운 예외 처리 코드를 작성할 수 있습니다.
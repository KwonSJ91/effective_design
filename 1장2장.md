# 이펙티브 소프트웨어 설계


# 1장 – 설계에서의 현실적인 선택과 패턴 적용

## 트레이드오프(trade-off)의 뜻 상충관계. 즉, 하나를 얻으면 다른 하나를 잃을 수 있는 관계를 말한다.

## 설계는 트레이드오프의 연속이다
소프트웨어 설계는 다양한 품질 속성 간의 균형을 고려하는 과정이다. 예를 들어, 성능을 높이기 위해 캐시를 도입하면 시스템 복잡도가 증가할 수 있고, 유지보수성을 고려해 모듈화를 심화하면 실행 성능이 저하될 수 있다. 이처럼 설계는 어떤 장점을 취하면 다른 단점을 감수해야 하는 선택의 연속이며, 이를 트레이드오프라고 한다. 이러한 개념을 이해하고 의식적으로 설계에 반영하는 것이 성숙한 개발자의 자세다.

## 테스트 전략의 현실
테스트는 단순히 코드의 오류를 잡는 수단이 아니라, 시스템의 신뢰성을 확보하고 변화에 안전하게 대응하기 위한 전략이다. 단위 테스트는 빠르고 작성이 쉬운 반면, 전체 시스템 흐름에서의 오류를 잡기에는 한계가 있다. 반면, 통합 테스트는 현실적인 시나리오를 검증할 수 있지만 작성과 실행 비용이 높고 유지보수도 어렵다. 효과적인 테스트 전략은 가장 중요한 리스크를 최소한의 비용으로 제어하는 것이 핵심이다.

## 디자인 패턴의 실제 적용
디자인 패턴은 반복적으로 나타나는 문제에 대해 검증된 해결책을 제공하지만, 만능은 아니다. 예를 들어 싱글턴 패턴은 인스턴스를 하나만 만들도록 제약하는 패턴으로 자주 사용되지만, 멀티스레드 환경에서는 성능과 안정성 문제를 유발할 수 있다.

### Synchronized 방식
```java
public class Singleton {
    private static Singleton instance;
    public static synchronized Singleton getInstance() {
        if (instance == null) instance = new Singleton();
        return instance;
    }
}
```
매 호출마다 동기화 처리가 발생하여 성능이 저하된다.

### Double Checked Locking 방식
```java
public class DCLSingleton {
    private static volatile DCLSingleton instance;
    public static DCLSingleton getInstance() {
        if (instance == null) {
            synchronized(DCLSingleton.class) {
                if (instance == null) instance = new DCLSingleton();
            }
        }
        return instance;
    }
}
```
필요한 시점에만 동기화를 걸어 성능을 개선하지만 구현이 복잡하다.

### ThreadLocal 방식
```java
public class ThreadLocalSingleton {
    private static final ThreadLocal<ThreadLocalSingleton> instance =
        ThreadLocal.withInitial(ThreadLocalSingleton::new);
    public static ThreadLocalSingleton getInstance() {
        return instance.get();
    }
}
```
스레드마다 독립된 인스턴스를 가지므로 동시성 문제 없이 성능이 좋지만, 메모리 관리에 주의가 필요하다.

## 벤치마크 결과 요약
실제 벤치마크 결과에서 synchronized 방식은 가장 느렸고, DCL과 ThreadLocal 방식은 상대적으로 빠른 응답을 보였다. 이처럼 구현 방식 하나가 성능에 큰 영향을 미치며, 이러한 선택 역시 설계의 일부다.

## 아키텍처 설계의 한계
마이크로서비스는 유연성과 확장성 면에서 뛰어나지만, 운영과 장애 관리가 복잡해진다. 반면, 모놀리식 구조는 단순하고 빠르게 개발할 수 있으나, 확장성과 장애 분리 측면에서는 한계가 있다. 어떤 구조를 선택하든 장단점이 존재하며, 상황에 따라 신중한 판단이 요구된다.

## 결론
설계는 기술적 선택이면서 동시에 전략적 판단이다. 도구와 패턴은 문제 해결을 위한 수단이며, 가장 적절한 설계는 현재의 문제를 가장 효과적으로 해결할 수 있는 구조다.



# 2장 – 코드 중복, 공통화, 그리고 적절한 분리 전략

## 코드 중복의 현실
코드 중복은 일반적으로 좋지 않다고 알려져 있지만, 무조건 제거해야 하는 것은 아니다. 특히 여러 팀이 독립적으로 서비스를 개발할 경우, 유사한 기능을 각자 구현하는 것이 오히려 효율적일 수 있다. 공통화가 지나치면 조율 비용이 높아지고, 변화에 민감해져 유지보수가 더 어려워질 수 있다.

## 공통 코드의 라이브러리화
중복된 기능을 공통 모듈로 묶어 라이브러리화하면 재사용성과 일관성을 확보할 수 있다. 하지만 이는 초기 설계, 문서화, 배포 절차 등 많은 노력이 필요하다. 팀 간 협업이 어렵거나, 기능 변경이 자주 일어나는 환경에서는 오히려 비효율적일 수 있다.

## 공통 기능을 마이크로서비스로 제공

### 인증 API 예시
```java
@RestController
@RequestMapping("/auth")
public class AuthController {
    @GetMapping("/validate")
    public boolean isValid(@RequestParam String token) {
        return jwtService.verify(token);
    }
}
```
공통 기능을 별도의 서비스로 제공하면 중복을 줄일 수 있지만, 네트워크 통신 비용, 장애 시 전파 문제, SLA 관리 등의 부담이 생긴다.

## 상속 기반 공통화 구조

### 추상 클래스 정의
```java
public abstract class TraceRequest {
    private final String userId;
    public TraceRequest(String userId) {
        this.userId = userId;
    }
    public abstract boolean isTraceEnabled();
}
```

### 하위 클래스 구현
```java
public class GraphTraceRequest extends TraceRequest {
    public GraphTraceRequest(String userId) {
        super(userId);
    }
    @Override
    public boolean isTraceEnabled() {
        return true;
    }
}
```
상속을 통해 공통 기능을 구조화할 수 있으나, 하위 클래스 간 결합도가 높아지고 유연성이 떨어질 수 있다.

## 합성 방식의 유연함
합성은 구성 요소를 조합해 기능을 구성하는 방식으로, 필요한 기능만 선택적으로 사용할 수 있어 유연성이 높다. 다만, 설계가 복잡해지고 학습 비용이 발생할 수 있으므로 주의가 필요하다.

## 중복의 본질적 구분
비슷한 코드라고 하더라도 목적이 다르면 공통화해서는 안 된다. 우연한 중복과 의도된 중복을 구분하여, 실제로 공통의 책임을 가지는 코드만 공유해야 한다.

## 결론
중복 제거는 그 자체가 목적이 아니라, 더 나은 유지보수성과 생산성을 위한 수단이다. 설계자는 팀의 환경과 시스템의 복잡도를 고려하여 신중하게 판단해야 한다.
